[style]
ALIGN_CLOSING_BRACKET_WITH_VISUAL_INDENT=True
#  Align closing bracket with visual indentation.

ALLOW_MULTILINE_LAMBDAS=False
#  Allow lambdas to be formatted on more than one line.

ALLOW_MULTILINE_DICTIONARY_KEYS=True
# Allow dictionary keys to exist on multiple lines. For example:
#    x = {
#        ('this is the first element of a tuple',
#        'this is the second element of a tuple'):
#        value,
#    }

ALLOW_SPLIT_BEFORE_DICT_VALUE=True
# Allow splits before the dictionary value.

BLANK_LINE_BEFORE_NESTED_CLASS_OR_DEF=False
#  Insert a blank line before a 'def' or 'class' immediately nested
#  within another 'def' or 'class'. For example:
#
#    class Foo:
#                       # <------ this blank line
#      def method():
#        ...

BLANK_LINE_BEFORE_CLASS_DOCSTRING=False
# Insert a blank line before a class-level docstring.

# COALESCE_BRACKETS=True
# Do not split consecutive brackets. Only relevant when DEDENT_CLOSING_BRACKETS is set. For example:
#    call_func_that_takes_a_dict(
#        {
#             'key1': 'value1',
#             'key2': 'value2',
#        }
#    )
# would reformat to:
#    call_func_that_takes_a_dict({
#        'key1': 'value1',
#        'key2': 'value2',
#    })

COLUMN_LIMIT=79
# The column limit (or max line-length)

CONTINUATION_INDENT_WIDTH=4
#  Indent width used for line continuations.

DEDENT_CLOSING_BRACKETS=True
#  Put closing brackets on a separate line, dedented, if the bracketed
#  expression can't fit in a single line. Applies to all kinds of brackets,
#  including function definitions and calls. For example:
#
#    config = {
#        'key1': 'value1',
#        'key2': 'value2',
#    }        # <--- this bracket is dedented and on a separate line
#
#    time_series = self.remote_client.query_entity_counters(
#        entity='dev3246.region1',
#        key='dns.query_latency_tcp',
#        transform=Transformation.AVERAGE(window=timedelta(seconds=60)),
#        start_ts=now()-timedelta(days=3),
#        end_ts=now(),
#    )        # <--- this bracket is dedented and on a separate line

EACH_DICT_ENTRY_ON_SEPARATE_LINE=False
# Place each dictionary entry onto its own line.

# I18N_COMMENT=
#  The regex for an i18n comment. The presence of this comment stops
#  reformatting of that line, because the comments are required to be
#  next to the string they translate.

# I18N_FUNCTION_CALL=
#  The i18n function call names. The presence of this function stops
#  reformattting on that line, because the string it has cannot be moved
#  away from the i18n comment.

INDENT_DICTIONARY_VALUE=True
#  Indent the dictionary value if it cannot fit on the same line as the
#  dictionary key. For example:
#
#    config = {
#        'key1':
#            'value1',
#        'key2': value1 +
#                value2,
#    }

INDENT_WIDTH=4
#  The number of columns to use for indentation.

JOIN_MULTIPLE_LINES=True
#  Join short lines into one line. E.g., single line 'if' statements.

SPACES_AROUND_POWER_OPERATOR=False
#  Use spaces around the power operator.

NO_SPACES_AROUND_SELECTED_BINARY_OPERATORS=True
# Do not include spaces around selected binary operators. For example:
#    1 + 2 * 3 - 4 / 5
# will be formatted as follows when configured with a value "*,/":
#    1 + 2*3 - 4/5

SPACES_AROUND_DEFAULT_OR_NAMED_ASSIGN=False
# Set to True to prefer spaces around the assignment operator for default or keyword arguments.

SPACES_BEFORE_COMMENT=2
#  The number of spaces required before a trailing comment.

SPACE_BETWEEN_ENDING_COMMA_AND_CLOSING_BRACKET=True
#  Insert a space between the ending comma and closing bracket of a list,
#  etc.

SPLIT_ARGUMENTS_WHEN_COMMA_TERMINATED=False
#  Split before arguments if the argument list is terminated by a
#  comma.

SPLIT_BEFORE_BITWISE_OPERATOR=False
#  Set to True to prefer splitting before '&', '|' or '^' rather than
#  after.

SPLIT_BEFORE_DICT_SET_GENERATOR=True
# Split before a dictionary or set generator (comp_for). For example, note the split before the for:
#    foo = {
#        variable: 'Hello world, have a nice day!'
#        for variable in bar if variable != 42
#    }

SPLIT_BEFORE_EXPRESSION_AFTER_OPENING_PAREN=True
# Split after the opening paren which surrounds an expression if it doesn't fit on a single line.

SPLIT_BEFORE_FIRST_ARGUMENT=False
#  If an argument / parameter list is going to be split, then split before
#  the first argument.

SPLIT_BEFORE_LOGICAL_OPERATOR=False
#  Set to True to prefer splitting before 'and' or 'or' rather than
#  after.

SPLIT_BEFORE_NAMED_ASSIGNS=True
#  Split named assignments onto individual lines.

SPLIT_COMPLEX_COMPREHENSION=True
# For list comprehensions and generator expressions with multiple clauses (e.g mutiple "for" calls, "if" filter expressions) and which need to be reflowed, split each clause onto its own line. For example:
#    result = [
#        a_var + b_var for a_var in xrange(1000) for b_var in xrange(1000)
#        if a_var % b_var]
# would reformat to something like:
#    result = [
#        a_var + b_var
#        for a_var in xrange(1000)
#        for b_var in xrange(1000)
#        if a_var % b_var]

SPLIT_PENALTY_AFTER_OPENING_BRACKET=30
#  The penalty for splitting right after the opening bracket.

SPLIT_PENALTY_AFTER_UNARY_OPERATOR=10000
#  The penalty for splitting the line after a unary operator.

SPLIT_PENALTY_BEFORE_IF_EXPR=0
#  The penalty for splitting right before an if expression.

SPLIT_PENALTY_BITWISE_OPERATOR=300
#  The penalty of splitting the line around the '&', '|', and '^'
#  operators.

# SPLIT_PENALTY_COMPREHENSION
# The penalty for splitting a list comprehension or generator expression.

SPLIT_PENALTY_EXCESS_CHARACTER=2600
#  The penalty for characters over the column limit.

SPLIT_PENALTY_FOR_ADDED_LINE_SPLIT=30
#  The penalty incurred by adding a line split to the unwrapped line. The
#  more line splits added the higher the penalty.

SPLIT_PENALTY_IMPORT_NAMES=0
#  The penalty of splitting a list of "import as" names. For example:
#
#    from a_very_long_or_indented_module_name_yada_yad import (long_argument_1,
#                                                              long_argument_2,
#                                                              long_argument_3)
#
#  would reformat to something like:
#
#    from a_very_long_or_indented_module_name_yada_yad import (
#        long_argument_1, long_argument_2, long_argument_3)

SPLIT_PENALTY_LOGICAL_OPERATOR=300
#  The penalty of splitting the line around the 'and' and 'or'
#  operators.

USE_TABS=False
#  Use the Tab character for indentation.
